# Pentester_tool
Pierwszym krokiem było sprawdzenie, jaka jest maska sieci by móc znaleźć IP naszego celu.
W funkcji `get_amount_hosts()` linijka 10 pobiera maskę podsieci z interface eth0
w linijce 11 maska podsieci jest konwertowana na adres cidr⁣, czyli np. /24, w ostatniej linijce zwracamy wynik działania, czyli liczbę hostów w danej sieci.

![1.png](../_resources/1.png)

Następnie mogliśmy przeskanować wszystkie IP w sieci.
W linijce 16 zaczynamy od wyznaczenia startowego ip, w kolejnej linijce robimy tzw. slice na startowym ip by wyglądał mniej więcej tak `192.168.1.`
W linijce 18 pobieramy ilość hostów z funkcji `get_amount_hosts()`, w linijce 19 tworzymy pętle `range`⁣, do której podajemy liczbę hostów. W linii 20 tworzymy zmienną `ip`, która zawiera już pełny adres ip. W kolejnej linijce tworzymy żądanie ICMP z ilością wysyłanych pakietów = 1, a w kolejnej linijce sprawdzamy, czy otrzymaliśmy pakiet, jeśli tak to zwracamy adres ip i kontynuuje działanie funkcji by znaleźć inne ip.

![2.png](../_resources/2.png)

Gdy znajdziemy jakiś adres ip to przechodzimy do funkcji `get_ports()` gdzie ta funkcja przyjmuje adres ip. Następnie w linii 28 tworzymy pustą listę `ports`, a następnie w linii 29 tworzymy pętle `range` gdzie wprowadzamy ilość portów. Następnie w pętli w linii 30 tworzymy nowy `socket`. 
Następnie w linii 32 sprawdzamy, czy metoda `connect_ex` zwróci błąd, czy `0`.  W linii 35 sprawdzamy, czy  metoda `connect_ex`  zwróciła `0` jeśli tak to dodajemy aktualny sprawdzany port do listy `ports` i zamykamy socket po zakończeniu się pętli zwracamy listę portów.

![3.png](../_resources/3.png)

Funkcja `get_banner()` przyjmuje dwa argumenty `ip` i `port`, w linii 41 tworzymy ponownie `socket` w następnej linii łączymy się z podanym ip i portem, następnie wysyłamy do socketu w bajtach tekst `Get Banner \r \n`, a następnie odbieramy dane z socketu w bajtach i rozszyfrujemy je dzięki metodzie `decode()` i w 2 ostatnich linijkach zapisujemy do pliku `data/banner_{ip}:{port}.txt` dane otrzymane z metody `socket.recv()`.

![4.png](../_resources/4.png)

Ostatnia funkcja robi enumeracje podstron. Ta funkcja przyjmuje 2 argumenty `file_withwords` - plik z nazwami do enumeracji i argument `ip` - ip celu.
W linii 51 wczytujemy plik ze słowami a w kolejnej linii tworzymy pętle gdzie sczytujemy plik po liniach by w kolejnej linii usunąć białe znaki. Następnie tworzymy żądanie do strony internetowej z dołączoną podstroną z pliku. I w linii 55 sprawdzamy `status_code` żądania, jeśli jest inny niż `404` to dopisuje podstronę i `status_code` do pliku `find_subpage.txt`. A jeśli jest `status_code` `404` to przechodzi dalej przez pętle od początku z kolejna nazwa podstrony z pliku.

![5.png](../_resources/5.png)

Po stworzeniu wszystkich podstawowych funkcji do rekonesansu tworzymy zmienna z funkcji `get_ip()`  a w następnej linijce tworzymy pętle z wszystkimi ip.
Następnie w pętli tworzymy kolejna zmienna z listą otwartych portów , by następnie do pliku `data/ip_and_ports.txt` dodać adres ip. W kolejnej 65 linijce tworzymy kolejna pętle, ale teraz związaną z portami. W tej pętli wywołujemy funkcję `enumeration_subpages()` i `get_banner()⁣`, a potem dodajemy do pliku `data/ip_and_ports.txt` znaleziony otwarty port.
W ostatniej linijce dodajemy do pliku `data/ip_and_ports.txt` pusty wiersz by oddzielić inne ip od siebie.